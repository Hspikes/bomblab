# 总结

兄弟无敌的，终于过了 secret phase
easy 啊，拿捏了。称还有点印象，写一写总结吧。

# Secret Phase

毫无疑问最难的一个，通过我惊人的洞察力，看出来了这是一个二叉树。在第一次做csapp的lab的时候我做phase6链表就没做明白，被混乱的字节对齐和gdb诡异的逻辑搞晕了，最后通过一些直觉和试错弄了出来。这次做ics的lab时也没把phase6搞明白。但是做完secret phase phase6肯定就不是问题了，本质是secret phase 是phase6的升级版，我还有其他事要做，确实忙，没办法。

是什么让我终于明白secret phase 了呢？准确来说是搞明白了链表，是一条gdb 指令。gdb 的x 和p两个指令非常让人困惑，x 是将后面的代码解释为一个地址，输出地址处的值，并通过\来控制格式。而p 是直接输出值，通过括号来控制格式，我之前始终没能搞明白我该怎么让x 输出地址，导致在内存中的指针我很难查验。

后来我发现用 p 也可以查内存，只用在内存表达式前面加* 比如 p (void*) *0x555555559140 就会以地址形式输出这个地址处的值。

这个phase 还有个难点就是递归函数，递归调用我用了前面一个phase4的技巧，还原成C，一般就能看清楚结构了。

然后就是最后一个难点，很奇怪，就是这个函数是在二叉树里查找值，并且必须要找到最下层最左边的值才能返回想要的$rax，但是进过漫长的地址分析，找到目标值后 x检出值为-23，直接炸肛了，很怪。实际上在内存里面是 0x3e9 不知道为什么 x出来会是-23。后来我发现一条新指令可以批量的检索内存x/200x 0x555555559050 第二个x前的数字是指明检索多少内存，其他和一般一样。通过这个指令我终于检索出来那一片是什么东西了。

其实我在还没有发现0x3e9的时候就发现了-23 0xffe9，加上输入又限制为 0x3e8+1，当时我就觉得答案应该是 0x3e8+1，结果我一直填答案填的 0x3e8，人晕了，结果没有误打误撞把答案撞出来真是太可惜了。

对了这个还有一个很恶心的是输入用了 C里面的 strtol 函数，纯恶心人。

其他的 phase 我其实都点记不清了，随便写写吧。

# Phase 1

两条指令都可以 p (char*) *address_num ; x/s address_num;

# Phase 2

没印象的路边。

# Phase 3

显然 switch case 试一试就可以了

# Phase 4

关键是看出来一个前面一大段都是在取中位数，其中有一个用位移法通过舍入向0取整比较难看。看出来了这个中位数，一下子就明朗了，显然是在二分。

# Phase 5

和CSAPP里的那个一模一样，答案都一样，我记得当时我做出CSAPP里面那个的时候巨激动，这次简单看了看就懂了。

# Phase 6

有点复杂，做了几次变换，后面又是一个链表。其实我当时没看懂链表，现在肯定能看懂了，毕竟有了 Secret Phase 的积累。我就不再去看了，原因和前文说的一样：忙。